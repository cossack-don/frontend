# Популярные практики

![Alt for Imsage](../css/images/styleelint.png)


№1) Отловить ошибки
Некоторые правила stylelint направлены на выявление очевидных ошибок, обычно опечаток или недосмотров, сделанных, когда вы торопились, отвлекались или у вас были затуманенные глаза. Например, вы можете запретить пустые блоки, недопустимые шестнадцатеричные значения, повторяющиеся селекторы, неизвестные имена анимации и ошибочный синтаксис линейного градиента.

Другие правила делают все возможное, чтобы выявить более тонкие ошибки.
Существует правило, которое предупреждает, когда вы использовали сокращенное свойство (например margin, ), которое переопределяет одно из его полных аналогов (например margin-top), что вы, вероятно, сделали непреднамеренно. И есть правило, чтобы предупредить вас о запутанной ситуации, когда правило A предшествует правилу B, но фактически переопределяет правило B, потому что селектор правила A имеет более высокую специфичность (например, правило A .foo.bar {...}и правило B .foo {...}). Это сложно.

Другое правило использует плагин PostCSS doiuse , чтобы проверить, будут ли ваши стили работать в браузерах, которые вы собираетесь поддерживать. И еще один использует css-colorguard , чтобы пожаловаться на цвета, настолько похожие, что вы, вероятно, хотели, чтобы они были идентичными. (Обратите внимание? Это одно из основных преимуществ того, что stylelint построен на основе PostCSS: с минимальными усилиями stylelint может вводить правила, которые используют другие аналитические плагины PostCSS .)

# 2) Применять лучшие практики
Если вы используете систематическую методологию в своих таблицах стилей или у вас есть руководство по стилю для вашего кода, вы сможете решительно запретить определенные шаблоны. stylelint предоставляет средства для этого.

Прежде всего, вам нужно контролировать свои селекторы. Безжалостно. С помощью stylelint вы можете запретить селекторы, превышающие определенную специфичность, или ограничить глубину вложенности. Вы можете запретить категории селекторов (например, селекторы без идентификатора) и предоставить регулярные выражения, чтобы обеспечить соблюдение соглашений об именах для остальных.

Вы можете заблокировать использование !importantхаков , или браузера, которые не применимы к поддерживаемым вами браузерам. Если вы используете Autoprefixer (что вам, вероятно, следует делать), вы можете запретить использование префиксов поставщиков в исходных таблицах стилей.

Если вы хотите действовать по-настоящему серьезно — потратив дополнительное время на настройку для обеспечения абсолютной согласованности, — вы можете установить порядок свойств в своих правилах и создать черные и белые списки для свойств, значений, функций и единиц измерения.

# 3) Обеспечьте соблюдение соглашений о стиле кода
В stylelint есть множество правил, которые автоматически применяют соглашения о стиле кода, так что вам и вашим товарищам по команде это не нужно. Мы постарались сделать эти правила максимально всеобъемлющими и чрезвычайно гибкими .

Эти правила в основном касаются пробелов, но также нацелены на другие детали, такие как кавычки, регистр букв, начальные нули в дробных числах, использование ключевых слов вместо написания значений и т. д.

Мечта состоит в том, чтобы вы и ваши товарищи по команде могли один раз установить соглашение о форматировании (например, «Давайте всегда будем ставить один пробел после двоеточия в объявлении!»), кодифицировать его в конфигурации stylelint и больше никогда об этом не говорить. Оставьте правоприменение империи машин.

# 4) Настроить и расширить все
Николас Закас, создатель ESLint (а также CSS Lint), писал , что ключом к успеху ESLint является его расширяемость. stylelint пытается последовать примеру ESLint и предоставить авторам CSS максимально расширяемый линтер.

Вы можете писать и публиковать свои собственные правила в виде плагинов. Уже есть куча доступных; и нам не терпится увидеть, что еще придумают люди.

Конфигурации расширяемы и, следовательно, доступны для совместного использования. Как и в случае с плагинами, мы узнали о ценности этой функции от ESLint. Посмотрите, что уже опубликовано , включая конфиги от WordPress и SUITCSS.

Если вам не нравятся встроенные отчеты stylelint, вы можете создать свои собственные, даже адаптированные для вашей организации. Вы также можете настроить предупреждающие сообщения, которые доставляют правила.

Используя API stylelint, вы можете создавать плагины для текстовых редакторов и исполнителей задач, которые интегрируют stylelint во все аспекты вашего рабочего процесса.

И если вы можете придумать какие-либо другие способы расширения stylelint, дайте нам знать!



Normalize.css — это небольшой файл CSS, обеспечивающий лучшую согласованность стилей HTML-элементов в разных браузерах. Это современная, готовая к HTML5 альтернатива традиционному сбросу CSS.

Сайт проекта Normalize.css
Исходный код Normalize.css на GitHub
В настоящее время Normalize.css в той или иной форме используется Twitter Bootstrap , HTML5 Boilerplate , GOV.UK , Rdio , CSS Tricks и многими другими фреймворками, наборами инструментов и сайтами.

Обзор
Normalize.css — это альтернатива сбросу CSS. Проект является результатом сотен часов обширных исследований @necolas и @jon_neal различий между стилями браузера по умолчанию.

Цели normalize.css заключаются в следующем:

Сохраняйте полезные настройки браузера по умолчанию , а не удаляйте их.
Нормализация стилей для широкого спектра элементов HTML.
Исправьте ошибки и распространенные несоответствия браузера.
Повысьте удобство использования с помощью незначительных улучшений.
Объясните код, используя комментарии и подробную документацию.
Он поддерживает широкий спектр браузеров (включая мобильные браузеры) и включает CSS, нормализующий элементы HTML5, типографику, списки, встроенное содержимое, формы и таблицы.

Несмотря на то, что проект основан на принципе нормализации, он использует прагматичные значения по умолчанию там, где они предпочтительнее.

Нормализация против сброса
Стоит подробнее разобраться, чем normalize.css отличается от традиционных сбросов CSS.

Normalize.css сохраняет полезные значения по умолчанию
Сбросы создают однородный визуальный стиль, сглаживая стили по умолчанию почти для всех элементов. Напротив, normalize.css сохраняет множество полезных стилей браузера по умолчанию. Это означает, что вам не нужно повторно объявлять стили для всех общих типографских элементов.

Когда элемент имеет разные стили по умолчанию в разных браузерах, normalize.css стремится сделать эти стили согласованными и, по возможности, соответствующими современным стандартам.

Normalize.css исправляет распространенные ошибки
Он исправляет распространенные ошибки настольного и мобильного браузера, которые не подлежат сбросу. Это включает в себя настройки отображения для элементов HTML5, исправление font-sizeпредварительно отформатированного текста, переполнение SVG в IE9 и множество ошибок, связанных с формами, в разных браузерах и операционных системах.

Например, вот как normalize.css делает новый searchтип ввода HTML5 кроссбраузерным и стильным:


Сбросы часто не приводят браузеры к исходной точке уровня в отношении того, как отображается элемент. Это особенно верно для форм — области, где normalize.css может оказать существенную помощь.


![Alt for Imsage](../css/images/normalaze.png)
Normalize.css не загромождает ваши инструменты отладки
Распространенным раздражением при использовании сбросов является большая цепочка наследования, отображаемая в инструментах отладки CSS браузера.


Обычное явление в инструментах отладки браузера при использовании сброса CSS
Это не такая проблема с normalize.css из-за целевых стилей и консервативного использования нескольких селекторов в наборах правил.

Normalize.css является модульным
Проект разбит на относительно независимые разделы, что позволяет вам легко увидеть, какие именно элементы нуждаются в определенных стилях. Кроме того, это дает вам возможность удалять разделы (например, нормализацию форм), если вы знаете, что они никогда не понадобятся вашему веб-сайту.

Normalize.css имеет обширную документацию.
Код normalize.css основан на подробном кросс-браузерном исследовании и методическом тестировании. Файл тщательно задокументирован и дополнительно расширен в GitHub Wiki . Это означает, что вы можете узнать, что делает каждая строка кода, почему она была включена, каковы различия между браузерами и более легко запускать свои собственные тесты.

Целью проекта является информирование людей о том, как браузеры отображают элементы по умолчанию, и облегчение участия в представлении улучшений.